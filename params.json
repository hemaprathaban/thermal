{"name":"Thermal management  Documentation","tagline":"","body":"``Intel thermal device management\r\n\r\nThe document explains the work carried for Linux thernal drivers for Intel internship.\r\n\r\nThe generic thermal management uses a concept of cooling states. \r\nThe intent of a cooling state is to define thermal modes for supporting devices. \r\nThe higher the cooling state, the lower the device/platform temperature would be. \r\nThis can be used for both passive and active cooling devices.\r\n\r\n    • Passive cooling -  does not use a fan or other means of forced-air cooling.  Relies on natural convection cooling.\r\n    • Active cooling -   uses a fan directly mounted onto the heat sink for forced-air cooling. \r\n  \r\nSysfs driver will redirect all the control requests to the appropriate cooling device driver when the user application sets a new cooling state. \r\n\r\nIt is up to the cooling device driver to  implement the actual cooling control.\r\n\r\nThermal management in user space would imply that all the policy decisions will be taken from user space and the kernel’s job would be only to facilitate those decisions.\r\n\r\nBelow explains the brief about thermal code how they are used how to register the cooling device\r\n\r\nIntel Thermal drivers code flow when you insmod \r\n 1. static int __init init(void) is called, this just calls pci_register_driver() to register intel_pch_thermal_driver.\r\n\r\n        a.intel_pch_thermal_driver is object of pci_driver structure and it populates\r\n            ▪ all the functions pointer, like probe, remove, shutdown. \r\n            ▪ name of the pci driver (name)\r\n            ▪ pci_id of the device.\t\r\n        b.So pci framework will automatically call our probe function when it sees a pci device with the device id we defined. \r\n      \r\n    2.intel_pch_thermal_probe() is called by pci framework.\r\n\r\n        a. it does pci device initialization, (it is understandable by reading)\r\n        b. initializes the intel_pch_thermal_device object ptdev.\r\n            ▪ get the memory to operate for register read/write by calling pci_iomap\r\n            ▪ assign particular device operation pch_dev_ops_cpt_ppt or pch_dev_ops_lpt depending on the device (ppt or lpt) in ptdev->ops.                   \r\n        c. register this device as thermal device by calling thermal_zone_device_register()\r\n           we pass tzd_ops object as thermal_zone_device_ops, so the functions mapped in this structure is called when related thermal \r\n          function is called.\r\n    3.when you call cat /sys/class/thermal/thermal_zone0/temp\r\n\r\n        a. since its a thermal core sysfs entry, \r\n              thermal core (thermal_zone_get_temp() in thermal_core.c) calls pch_thermal_get_temp function.\r\n              which inturn calls pch_cpt_ppt_get_temp , which inturn calls pch_thermal_mem_readb to read the register at the offset TSTR_PPT to get the temperature. \r\n     \r\n\r\n    4. device registers and their bitmasks for each bit or combination of bits are defined in the code. for example\r\n\r\n/* Register address for enabling Thermal Sensor*/\r\n#define TSE_PPT\t0x01 /* was TSC0 in DPTF */and its bitmasks are,\r\n\r\n/* Bit 7: Thermal sensor enable - must be enabled */\r\n#define TSE_PPT_EN\t(1 << 7)  -- set the 7th bit to enable Thermal sensor\r\n\r\n/* Bit 6: Analog hysteresis control - must be disabled */\r\n#define TSE_PPT_AHC   (1 << 6) -- set the 6th bit to disable Analog hysteresis control \r\n\r\n/* Bit 5-4: Digital hysteresis amount - must not be 00; 01 - 1C; 10 - 2C;\r\n *   11 - 3C\r\n */\r\n#define TSE_PPT_DHA   (3 << 4)  -- set bits 5 and 4 for  Digital hysteresis amount\r\n\r\n/* Bit 3-2: Sequencer enable and rate - must not be 00 */\r\n#define TSE_PPT_SER   (3 << 2) -- set bits 3 and 2 for Sequencer enable and rate\r\n\r\n/* Bit 1: Thermal sensor output select - 0: catastrophic, 1: hot;\r\n * recommended is 1\r\n */\r\n#define TSE_PPT_OUT   (1 << 1) -- set bit 1 to select the output mode.\r\n\r\n\r\nSo to enable thermal sensor, first read whatever the default value in the register\r\n    •  value = read(0x01) and \r\n    •  write (value|TSE_PPT_EN, 0x01) -- we are ORing the ‘value’ with TSE_PPT_EN and writing to register 0x01.\r\nA sensor can be anything that can sense the thermal or the temperature level.\r\n\r\nA cooling device can be anything which can cool the device hardware for example it can be a  fan or heatsink. But a fan or heatsink can be applicable only for laptops or pc. So small devices like mobile phones and tablets don't have a fan or heatsink. In this case a cooling device can be a software like controlling a cpu frequency to reduce the power 2.\r\n\r\nAs for I understand the generic layer provide thermal zone for each sensor.  These thermal zone can attach any cooling devices depending on trip point. Trip point is basically a particular level of thermal management. Depending on the level a specific cooling device will be chosen. This process is called binding and  binding api is called whenever a cooling device is attached to thermal zone. When the device reaches a particular trip point the relevant cooling device is called  from the thermal Zone. A thermal  zone can attach any number of cooling devices for various trip point levels.\r\n\r\ncpufreq: (drivers/cpufreq)\r\n\r\nhttp://doc.opensuse.org/products/draft/SLES/SLES-tuning_sd_draft/cha.tuning.power.html\r\nGeneric  CPU cooling support: (drivers/thermal)\r\n\r\n `config CPU_THERMAL`\r\n    \t`bool \"generic cpu cooling support\"`\r\n    \t`depends on CPU_FREQ`\r\n    \t`select CPU_FREQ_TABLE`\r\n    \t`help`\r\n\r\nThis implements the generic cpu cooling mechanism through frequency\r\nreduction. An ACPI version of this already exists (drivers/acpi/processor_thermal.c).\r\nThis will be useful for platforms using the generic thermal interface and not the ACPI interface.\r\n\r\nthermal_sys-$(CONFIG_CPU_THERMAL)   \t+= cpu_cooling.o\r\n\r\n\r\nPower Clamp driver: (drivers/thermal)\r\n\r\nlinux/Documentation/thermal/intel_powerclamp.txt\r\n   \r\n   `config INTEL_POWERCLAMP`\r\n        `tristate \"Intel PowerClamp idle injection driver\"`\r\n\t`depends on THERMAL`\r\n \t`depends on X86`\r\n  \t`depends on CPU_SUP_INTEL`\r\n \t`help`\r\n\r\nEnable this to enable Intel PowerClamp idle injection driver. This\r\nenforce idle time which results in more package C-state residency. The\r\nuser interface is exposed via generic thermal framework.\r\n\r\nobj-$(CONFIG_INTEL_POWERCLAMP)  += intel_powerclamp.o\r\n\r\nThis is basic understanding regarding the intel cooling device, based on this learning commits are done \r\nlike registering cooling device, use_define_PCI_table \r\n\r\n[commits](https://github.com/hemaprathaban/thermal/commits/hema_thermal)\r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}